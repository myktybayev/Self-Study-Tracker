"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/goals/[id]/page",{

/***/ "(app-pages-browser)/./src/lib/goals.ts":
/*!**************************!*\
  !*** ./src/lib/goals.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addGitHubPushToGoal: function() { return /* binding */ addGitHubPushToGoal; },\n/* harmony export */   addTaskToGoal: function() { return /* binding */ addTaskToGoal; },\n/* harmony export */   createGoal: function() { return /* binding */ createGoal; },\n/* harmony export */   createTask: function() { return /* binding */ createTask; },\n/* harmony export */   deleteGoal: function() { return /* binding */ deleteGoal; },\n/* harmony export */   deleteTask: function() { return /* binding */ deleteTask; },\n/* harmony export */   getGoalById: function() { return /* binding */ getGoalById; },\n/* harmony export */   getGoalTasks: function() { return /* binding */ getGoalTasks; },\n/* harmony export */   getGoalsByStatus: function() { return /* binding */ getGoalsByStatus; },\n/* harmony export */   getUserGoals: function() { return /* binding */ getUserGoals; },\n/* harmony export */   updateGoal: function() { return /* binding */ updateGoal; },\n/* harmony export */   updateTask: function() { return /* binding */ updateTask; },\n/* harmony export */   updateTaskInGoal: function() { return /* binding */ updateTaskInGoal; }\n/* harmony export */ });\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n\n\n// Helper function to check if Firebase is available\nconst isFirebaseAvailable = ()=>{\n    return _firebase__WEBPACK_IMPORTED_MODULE_0__.db !== undefined;\n};\n// Helper function to get user goals subcollection reference\nconst getUserGoalsCollection = (userId)=>{\n    if (!isFirebaseAvailable()) {\n        throw new Error(\"Firebase is not available\");\n    }\n    return (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"goals\", userId, \"userGoals\");\n};\n// Helper function to get user document reference\nconst getUserDocument = (userId)=>{\n    if (!isFirebaseAvailable()) {\n        throw new Error(\"Firebase is not available\");\n    }\n    return (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"goals\", userId);\n};\n// Helper function to get tasks subcollection reference\nconst getTasksCollection = (userId, goalId)=>{\n    if (!isFirebaseAvailable()) {\n        throw new Error(\"Firebase is not available\");\n    }\n    return (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"goals\", userId, \"userGoals\", goalId, \"tasks\");\n};\n// Create a new goal\nconst createGoal = async (goalData)=>{\n    if (!isFirebaseAvailable()) {\n        throw new Error(\"Firebase is not available\");\n    }\n    const { userId, ...goalWithoutUserId } = goalData;\n    // First, ensure user document exists\n    const userDocRef = getUserDocument(userId);\n    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(userDocRef, {\n        userId,\n        createdAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.now(),\n        updatedAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.now()\n    }, {\n        merge: true\n    });\n    const goalWithTimestamps = {\n        ...goalWithoutUserId,\n        createdAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.now(),\n        updatedAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.now()\n    };\n    const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)(getUserGoalsCollection(userId), goalWithTimestamps);\n    return docRef.id;\n};\n// Create a new task for a goal\nconst createTask = async (userId, goalId, taskData)=>{\n    if (!isFirebaseAvailable()) {\n        throw new Error(\"Firebase is not available\");\n    }\n    const taskWithTimestamps = {\n        ...taskData,\n        createdAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.now(),\n        updatedAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.now()\n    };\n    const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)(getTasksCollection(userId, goalId), taskWithTimestamps);\n    return docRef.id;\n};\n// Get all tasks for a specific goal\nconst getGoalTasks = async (userId, goalId)=>{\n    if (!isFirebaseAvailable()) {\n        console.warn(\"Firebase not available, returning empty array\");\n        return [];\n    }\n    try {\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(getTasksCollection(userId, goalId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"asc\"));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        return querySnapshot.docs.map((doc)=>{\n            var _doc_data_createdAt, _doc_data_updatedAt;\n            return {\n                id: doc.id,\n                ...doc.data(),\n                createdAt: ((_doc_data_createdAt = doc.data().createdAt) === null || _doc_data_createdAt === void 0 ? void 0 : _doc_data_createdAt.toDate()) || new Date(),\n                updatedAt: ((_doc_data_updatedAt = doc.data().updatedAt) === null || _doc_data_updatedAt === void 0 ? void 0 : _doc_data_updatedAt.toDate()) || new Date()\n            };\n        });\n    } catch (error) {\n        console.error(\"Error getting goal tasks:\", error);\n        return [];\n    }\n};\n// Update a task\nconst updateTask = async (userId, goalId, taskId, updates)=>{\n    if (!isFirebaseAvailable()) {\n        throw new Error(\"Firebase is not available\");\n    }\n    const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"goals\", userId, \"userGoals\", goalId, \"tasks\", taskId);\n    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(docRef, {\n        ...updates,\n        updatedAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.now()\n    });\n};\n// Delete a task\nconst deleteTask = async (userId, goalId, taskId)=>{\n    if (!isFirebaseAvailable()) {\n        throw new Error(\"Firebase is not available\");\n    }\n    const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"goals\", userId, \"userGoals\", goalId, \"tasks\", taskId);\n    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.deleteDoc)(docRef);\n};\n// Get all goals for a specific user\nconst getUserGoals = async (userId)=>{\n    if (!isFirebaseAvailable()) {\n        console.warn(\"Firebase not available, returning empty array\");\n        return [];\n    }\n    try {\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(getUserGoalsCollection(userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        return querySnapshot.docs.map((doc)=>{\n            var _doc_data_createdAt, _doc_data_updatedAt, _doc_data_targetDate;\n            return {\n                id: doc.id,\n                userId,\n                ...doc.data(),\n                createdAt: ((_doc_data_createdAt = doc.data().createdAt) === null || _doc_data_createdAt === void 0 ? void 0 : _doc_data_createdAt.toDate()) || new Date(),\n                updatedAt: ((_doc_data_updatedAt = doc.data().updatedAt) === null || _doc_data_updatedAt === void 0 ? void 0 : _doc_data_updatedAt.toDate()) || new Date(),\n                targetDate: ((_doc_data_targetDate = doc.data().targetDate) === null || _doc_data_targetDate === void 0 ? void 0 : _doc_data_targetDate.toDate()) || new Date()\n            };\n        });\n    } catch (error) {\n        console.error(\"Error getting user goals:\", error);\n        return [];\n    }\n};\n// Get a specific goal by ID\nconst getGoalById = async (userId, goalId)=>{\n    if (!isFirebaseAvailable()) {\n        throw new Error(\"Firebase is not available\");\n    }\n    try {\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"goals\", userId, \"userGoals\", goalId);\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(docRef);\n        if (docSnap.exists()) {\n            var _data_createdAt, _data_updatedAt, _data_targetDate;\n            const data = docSnap.data();\n            return {\n                id: docSnap.id,\n                userId,\n                ...data,\n                createdAt: ((_data_createdAt = data.createdAt) === null || _data_createdAt === void 0 ? void 0 : _data_createdAt.toDate()) || new Date(),\n                updatedAt: ((_data_updatedAt = data.updatedAt) === null || _data_updatedAt === void 0 ? void 0 : _data_updatedAt.toDate()) || new Date(),\n                targetDate: ((_data_targetDate = data.targetDate) === null || _data_targetDate === void 0 ? void 0 : _data_targetDate.toDate()) || new Date()\n            };\n        } else {\n            return null;\n        }\n    } catch (error) {\n        console.error(\"Error getting goal:\", error);\n        return null;\n    }\n};\n// Update a goal\nconst updateGoal = async (userId, goalId, updates)=>{\n    if (!isFirebaseAvailable()) {\n        throw new Error(\"Firebase is not available\");\n    }\n    const { userId: _, ...updatesWithoutUserId } = updates; // Remove userId from updates\n    const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"goals\", userId, \"userGoals\", goalId);\n    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(docRef, {\n        ...updatesWithoutUserId,\n        updatedAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.now()\n    });\n};\n// Delete a goal\nconst deleteGoal = async (userId, goalId)=>{\n    if (!isFirebaseAvailable()) {\n        throw new Error(\"Firebase is not available\");\n    }\n    const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"goals\", userId, \"userGoals\", goalId);\n    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.deleteDoc)(docRef);\n};\n// Add a task to a goal (legacy function - use createTask instead)\nconst addTaskToGoal = async (userId, goalId, task)=>{\n    if (!isFirebaseAvailable()) {\n        throw new Error(\"Firebase is not available\");\n    }\n    const goal = await getGoalById(userId, goalId);\n    if (!goal) {\n        throw new Error(\"Goal not found\");\n    }\n    const newTask = {\n        ...task,\n        id: \"task_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9))\n    };\n    const updatedTasks = [\n        ...goal.tasks,\n        newTask\n    ];\n    await updateGoal(userId, goalId, {\n        tasks: updatedTasks\n    });\n};\n// Update a task in a goal (legacy function - use updateTask instead)\nconst updateTaskInGoal = async (userId, goalId, taskId, updates)=>{\n    if (!isFirebaseAvailable()) {\n        throw new Error(\"Firebase is not available\");\n    }\n    const goal = await getGoalById(userId, goalId);\n    if (!goal) {\n        throw new Error(\"Goal not found\");\n    }\n    const updatedTasks = goal.tasks.map((task)=>task.id === taskId ? {\n            ...task,\n            ...updates\n        } : task);\n    await updateGoal(userId, goalId, {\n        tasks: updatedTasks\n    });\n};\n// Add a GitHub push to a goal\nconst addGitHubPushToGoal = async (userId, goalId, push)=>{\n    if (!isFirebaseAvailable()) {\n        throw new Error(\"Firebase is not available\");\n    }\n    const goal = await getGoalById(userId, goalId);\n    if (!goal) {\n        throw new Error(\"Goal not found\");\n    }\n    const newPush = {\n        ...push,\n        id: \"push_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9))\n    };\n    const updatedPushes = [\n        ...goal.githubPushes,\n        newPush\n    ];\n    await updateGoal(userId, goalId, {\n        githubPushes: updatedPushes\n    });\n};\n// Get goals by status for a specific user\nconst getGoalsByStatus = async (userId, status)=>{\n    if (!isFirebaseAvailable()) {\n        console.warn(\"Firebase not available, returning empty array\");\n        return [];\n    }\n    try {\n        let q;\n        if (status === \"all\") {\n            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(getUserGoalsCollection(userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"));\n        } else {\n            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(getUserGoalsCollection(userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"status\", \"==\", status), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"createdAt\", \"desc\"));\n        }\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        return querySnapshot.docs.map((doc)=>{\n            var _doc_data_createdAt, _doc_data_updatedAt, _doc_data_targetDate;\n            return {\n                id: doc.id,\n                userId,\n                ...doc.data(),\n                createdAt: ((_doc_data_createdAt = doc.data().createdAt) === null || _doc_data_createdAt === void 0 ? void 0 : _doc_data_createdAt.toDate()) || new Date(),\n                updatedAt: ((_doc_data_updatedAt = doc.data().updatedAt) === null || _doc_data_updatedAt === void 0 ? void 0 : _doc_data_updatedAt.toDate()) || new Date(),\n                targetDate: ((_doc_data_targetDate = doc.data().targetDate) === null || _doc_data_targetDate === void 0 ? void 0 : _doc_data_targetDate.toDate()) || new Date()\n            };\n        });\n    } catch (error) {\n        console.error(\"Error getting goals by status:\", error);\n        return [];\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFzQm9DLE1BQU0sT0FBTSxJQUFJQztnQkFDakRqQixXQUFXcEIsRUFBQUEsc0JBQUFBLElBQUltQyxJQUFJLEdBQUdmLFNBQVMsY0FBcEJwQiwwQ0FBQUEsb0JBQXNCb0MsTUFBTSxPQUFNLElBQUlDO2dCQUNqRE8sWUFBWTVDLEVBQUFBLHVCQUFBQSxJQUFJbUMsSUFBSSxHQUFHUyxVQUFVLGNBQXJCNUMsMkNBQUFBLHFCQUF1Qm9DLE1BQU0sT0FBTSxJQUFJQztZQUN2RDs7SUFDSixFQUFFLE9BQU9DLE9BQU87UUFDWlQsUUFBUVMsS0FBSyxDQUFDLGtDQUFrQ0E7UUFDaEQsT0FBTyxFQUFFO0lBQ2I7QUFDSixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvZ29hbHMudHM/ZjI0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkYiB9IGZyb20gJy4vZmlyZWJhc2UnO1xuaW1wb3J0IHsgY29sbGVjdGlvbiwgYWRkRG9jLCBnZXREb2NzLCBnZXREb2MsIHVwZGF0ZURvYywgZGVsZXRlRG9jLCBkb2MsIHF1ZXJ5LCB3aGVyZSwgb3JkZXJCeSwgVGltZXN0YW1wLCBzZXREb2MgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xuaW1wb3J0IHsgR29hbCwgVGFzaywgR2l0SHViUHVzaCB9IGZyb20gJ0AvdHlwZXMvZ29hbCc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBGaXJlYmFzZSBpcyBhdmFpbGFibGVcbmNvbnN0IGlzRmlyZWJhc2VBdmFpbGFibGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGRiICE9PSB1bmRlZmluZWQ7XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHVzZXIgZ29hbHMgc3ViY29sbGVjdGlvbiByZWZlcmVuY2VcbmNvbnN0IGdldFVzZXJHb2Fsc0NvbGxlY3Rpb24gPSAodXNlcklkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIWlzRmlyZWJhc2VBdmFpbGFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcmViYXNlIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24oZGIhLCAnZ29hbHMnLCB1c2VySWQsICd1c2VyR29hbHMnKTtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdXNlciBkb2N1bWVudCByZWZlcmVuY2VcbmNvbnN0IGdldFVzZXJEb2N1bWVudCA9ICh1c2VySWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghaXNGaXJlYmFzZUF2YWlsYWJsZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyZWJhc2UgaXMgbm90IGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICByZXR1cm4gZG9jKGRiISwgJ2dvYWxzJywgdXNlcklkKTtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGFza3Mgc3ViY29sbGVjdGlvbiByZWZlcmVuY2VcbmNvbnN0IGdldFRhc2tzQ29sbGVjdGlvbiA9ICh1c2VySWQ6IHN0cmluZywgZ29hbElkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIWlzRmlyZWJhc2VBdmFpbGFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcmViYXNlIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24oZGIhLCAnZ29hbHMnLCB1c2VySWQsICd1c2VyR29hbHMnLCBnb2FsSWQsICd0YXNrcycpO1xufTtcblxuLy8gQ3JlYXRlIGEgbmV3IGdvYWxcbmV4cG9ydCBjb25zdCBjcmVhdGVHb2FsID0gYXN5bmMgKGdvYWxEYXRhOiBPbWl0PEdvYWwsICdpZCcgfCAnY3JlYXRlZEF0JyB8ICd1cGRhdGVkQXQnPik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgaWYgKCFpc0ZpcmViYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJlYmFzZSBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyB1c2VySWQsIC4uLmdvYWxXaXRob3V0VXNlcklkIH0gPSBnb2FsRGF0YTtcblxuICAgIC8vIEZpcnN0LCBlbnN1cmUgdXNlciBkb2N1bWVudCBleGlzdHNcbiAgICBjb25zdCB1c2VyRG9jUmVmID0gZ2V0VXNlckRvY3VtZW50KHVzZXJJZCk7XG4gICAgYXdhaXQgc2V0RG9jKHVzZXJEb2NSZWYsIHtcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBjcmVhdGVkQXQ6IFRpbWVzdGFtcC5ub3coKSxcbiAgICAgICAgdXBkYXRlZEF0OiBUaW1lc3RhbXAubm93KClcbiAgICB9LCB7IG1lcmdlOiB0cnVlIH0pO1xuXG4gICAgY29uc3QgZ29hbFdpdGhUaW1lc3RhbXBzID0ge1xuICAgICAgICAuLi5nb2FsV2l0aG91dFVzZXJJZCxcbiAgICAgICAgY3JlYXRlZEF0OiBUaW1lc3RhbXAubm93KCksXG4gICAgICAgIHVwZGF0ZWRBdDogVGltZXN0YW1wLm5vdygpLFxuICAgIH07XG5cbiAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2MoZ2V0VXNlckdvYWxzQ29sbGVjdGlvbih1c2VySWQpLCBnb2FsV2l0aFRpbWVzdGFtcHMpO1xuICAgIHJldHVybiBkb2NSZWYuaWQ7XG59O1xuXG4vLyBDcmVhdGUgYSBuZXcgdGFzayBmb3IgYSBnb2FsXG5leHBvcnQgY29uc3QgY3JlYXRlVGFzayA9IGFzeW5jICh1c2VySWQ6IHN0cmluZywgZ29hbElkOiBzdHJpbmcsIHRhc2tEYXRhOiBPbWl0PFRhc2ssICdpZCcgfCAnY3JlYXRlZEF0JyB8ICd1cGRhdGVkQXQnPik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgaWYgKCFpc0ZpcmViYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJlYmFzZSBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGFza1dpdGhUaW1lc3RhbXBzID0ge1xuICAgICAgICAuLi50YXNrRGF0YSxcbiAgICAgICAgY3JlYXRlZEF0OiBUaW1lc3RhbXAubm93KCksXG4gICAgICAgIHVwZGF0ZWRBdDogVGltZXN0YW1wLm5vdygpLFxuICAgIH07XG5cbiAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2MoZ2V0VGFza3NDb2xsZWN0aW9uKHVzZXJJZCwgZ29hbElkKSwgdGFza1dpdGhUaW1lc3RhbXBzKTtcbiAgICByZXR1cm4gZG9jUmVmLmlkO1xufTtcblxuLy8gR2V0IGFsbCB0YXNrcyBmb3IgYSBzcGVjaWZpYyBnb2FsXG5leHBvcnQgY29uc3QgZ2V0R29hbFRhc2tzID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nLCBnb2FsSWQ6IHN0cmluZyk6IFByb21pc2U8VGFza1tdPiA9PiB7XG4gICAgaWYgKCFpc0ZpcmViYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGaXJlYmFzZSBub3QgYXZhaWxhYmxlLCByZXR1cm5pbmcgZW1wdHkgYXJyYXknKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHEgPSBxdWVyeShcbiAgICAgICAgICAgIGdldFRhc2tzQ29sbGVjdGlvbih1c2VySWQsIGdvYWxJZCksXG4gICAgICAgICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnYXNjJylcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcXVlcnlTbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcbiAgICAgICAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAgICAgICAuLi5kb2MuZGF0YSgpLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBkb2MuZGF0YSgpLmNyZWF0ZWRBdD8udG9EYXRlKCkgfHwgbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogZG9jLmRhdGEoKS51cGRhdGVkQXQ/LnRvRGF0ZSgpIHx8IG5ldyBEYXRlKCksXG4gICAgICAgIH0pKSBhcyBUYXNrW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBnb2FsIHRhc2tzOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07XG5cbi8vIFVwZGF0ZSBhIHRhc2tcbmV4cG9ydCBjb25zdCB1cGRhdGVUYXNrID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nLCBnb2FsSWQ6IHN0cmluZywgdGFza0lkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8VGFzaz4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoIWlzRmlyZWJhc2VBdmFpbGFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcmViYXNlIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBkb2NSZWYgPSBkb2MoZGIhLCAnZ29hbHMnLCB1c2VySWQsICd1c2VyR29hbHMnLCBnb2FsSWQsICd0YXNrcycsIHRhc2tJZCk7XG4gICAgYXdhaXQgdXBkYXRlRG9jKGRvY1JlZiwge1xuICAgICAgICAuLi51cGRhdGVzLFxuICAgICAgICB1cGRhdGVkQXQ6IFRpbWVzdGFtcC5ub3coKSxcbiAgICB9KTtcbn07XG5cbi8vIERlbGV0ZSBhIHRhc2tcbmV4cG9ydCBjb25zdCBkZWxldGVUYXNrID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nLCBnb2FsSWQ6IHN0cmluZywgdGFza0lkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoIWlzRmlyZWJhc2VBdmFpbGFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcmViYXNlIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBkb2NSZWYgPSBkb2MoZGIhLCAnZ29hbHMnLCB1c2VySWQsICd1c2VyR29hbHMnLCBnb2FsSWQsICd0YXNrcycsIHRhc2tJZCk7XG4gICAgYXdhaXQgZGVsZXRlRG9jKGRvY1JlZik7XG59O1xuXG4vLyBHZXQgYWxsIGdvYWxzIGZvciBhIHNwZWNpZmljIHVzZXJcbmV4cG9ydCBjb25zdCBnZXRVc2VyR29hbHMgPSBhc3luYyAodXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPEdvYWxbXT4gPT4ge1xuICAgIGlmICghaXNGaXJlYmFzZUF2YWlsYWJsZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmlyZWJhc2Ugbm90IGF2YWlsYWJsZSwgcmV0dXJuaW5nIGVtcHR5IGFycmF5Jyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBxID0gcXVlcnkoXG4gICAgICAgICAgICBnZXRVc2VyR29hbHNDb2xsZWN0aW9uKHVzZXJJZCksXG4gICAgICAgICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHF1ZXJ5U25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XG4gICAgICAgICAgICBpZDogZG9jLmlkLFxuICAgICAgICAgICAgdXNlcklkLCAvLyBBZGQgdXNlcklkIGJhY2sgdG8gdGhlIGdvYWwgb2JqZWN0XG4gICAgICAgICAgICAuLi5kb2MuZGF0YSgpLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBkb2MuZGF0YSgpLmNyZWF0ZWRBdD8udG9EYXRlKCkgfHwgbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogZG9jLmRhdGEoKS51cGRhdGVkQXQ/LnRvRGF0ZSgpIHx8IG5ldyBEYXRlKCksXG4gICAgICAgICAgICB0YXJnZXREYXRlOiBkb2MuZGF0YSgpLnRhcmdldERhdGU/LnRvRGF0ZSgpIHx8IG5ldyBEYXRlKCksXG4gICAgICAgIH0pKSBhcyBHb2FsW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIGdvYWxzOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07XG5cbi8vIEdldCBhIHNwZWNpZmljIGdvYWwgYnkgSURcbmV4cG9ydCBjb25zdCBnZXRHb2FsQnlJZCA9IGFzeW5jICh1c2VySWQ6IHN0cmluZywgZ29hbElkOiBzdHJpbmcpOiBQcm9taXNlPEdvYWwgfCBudWxsPiA9PiB7XG4gICAgaWYgKCFpc0ZpcmViYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJlYmFzZSBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZG9jUmVmID0gZG9jKGRiISwgJ2dvYWxzJywgdXNlcklkLCAndXNlckdvYWxzJywgZ29hbElkKTtcbiAgICAgICAgY29uc3QgZG9jU25hcCA9IGF3YWl0IGdldERvYyhkb2NSZWYpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGRvY1NuYXAuZXhpc3RzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBkb2NTbmFwLmRhdGEoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGRvY1NuYXAuaWQsXG4gICAgICAgICAgICAgICAgdXNlcklkLCAvLyBBZGQgdXNlcklkIGJhY2sgdG8gdGhlIGdvYWwgb2JqZWN0XG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IGRhdGEuY3JlYXRlZEF0Py50b0RhdGUoKSB8fCBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogZGF0YS51cGRhdGVkQXQ/LnRvRGF0ZSgpIHx8IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgdGFyZ2V0RGF0ZTogZGF0YS50YXJnZXREYXRlPy50b0RhdGUoKSB8fCBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgfSBhcyBHb2FsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGdvYWw6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vLyBVcGRhdGUgYSBnb2FsXG5leHBvcnQgY29uc3QgdXBkYXRlR29hbCA9IGFzeW5jICh1c2VySWQ6IHN0cmluZywgZ29hbElkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8R29hbD4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoIWlzRmlyZWJhc2VBdmFpbGFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcmViYXNlIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHVzZXJJZDogXywgLi4udXBkYXRlc1dpdGhvdXRVc2VySWQgfSA9IHVwZGF0ZXM7IC8vIFJlbW92ZSB1c2VySWQgZnJvbSB1cGRhdGVzXG4gICAgY29uc3QgZG9jUmVmID0gZG9jKGRiISwgJ2dvYWxzJywgdXNlcklkLCAndXNlckdvYWxzJywgZ29hbElkKTtcbiAgICBhd2FpdCB1cGRhdGVEb2MoZG9jUmVmLCB7XG4gICAgICAgIC4uLnVwZGF0ZXNXaXRob3V0VXNlcklkLFxuICAgICAgICB1cGRhdGVkQXQ6IFRpbWVzdGFtcC5ub3coKSxcbiAgICB9KTtcbn07XG5cbi8vIERlbGV0ZSBhIGdvYWxcbmV4cG9ydCBjb25zdCBkZWxldGVHb2FsID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nLCBnb2FsSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmICghaXNGaXJlYmFzZUF2YWlsYWJsZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyZWJhc2UgaXMgbm90IGF2YWlsYWJsZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGRvY1JlZiA9IGRvYyhkYiEsICdnb2FscycsIHVzZXJJZCwgJ3VzZXJHb2FscycsIGdvYWxJZCk7XG4gICAgYXdhaXQgZGVsZXRlRG9jKGRvY1JlZik7XG59O1xuXG4vLyBBZGQgYSB0YXNrIHRvIGEgZ29hbCAobGVnYWN5IGZ1bmN0aW9uIC0gdXNlIGNyZWF0ZVRhc2sgaW5zdGVhZClcbmV4cG9ydCBjb25zdCBhZGRUYXNrVG9Hb2FsID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nLCBnb2FsSWQ6IHN0cmluZywgdGFzazogT21pdDxUYXNrLCAnaWQnPik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmICghaXNGaXJlYmFzZUF2YWlsYWJsZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyZWJhc2UgaXMgbm90IGF2YWlsYWJsZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGdvYWwgPSBhd2FpdCBnZXRHb2FsQnlJZCh1c2VySWQsIGdvYWxJZCk7XG4gICAgaWYgKCFnb2FsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR29hbCBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdUYXNrOiBUYXNrID0ge1xuICAgICAgICAuLi50YXNrLFxuICAgICAgICBpZDogYHRhc2tfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gLFxuICAgIH07XG5cbiAgICBjb25zdCB1cGRhdGVkVGFza3MgPSBbLi4uZ29hbC50YXNrcywgbmV3VGFza107XG4gICAgYXdhaXQgdXBkYXRlR29hbCh1c2VySWQsIGdvYWxJZCwgeyB0YXNrczogdXBkYXRlZFRhc2tzIH0pO1xufTtcblxuLy8gVXBkYXRlIGEgdGFzayBpbiBhIGdvYWwgKGxlZ2FjeSBmdW5jdGlvbiAtIHVzZSB1cGRhdGVUYXNrIGluc3RlYWQpXG5leHBvcnQgY29uc3QgdXBkYXRlVGFza0luR29hbCA9IGFzeW5jICh1c2VySWQ6IHN0cmluZywgZ29hbElkOiBzdHJpbmcsIHRhc2tJZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPFRhc2s+KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKCFpc0ZpcmViYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJlYmFzZSBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZ29hbCA9IGF3YWl0IGdldEdvYWxCeUlkKHVzZXJJZCwgZ29hbElkKTtcbiAgICBpZiAoIWdvYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHb2FsIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZWRUYXNrcyA9IGdvYWwudGFza3MubWFwKHRhc2sgPT5cbiAgICAgICAgdGFzay5pZCA9PT0gdGFza0lkID8geyAuLi50YXNrLCAuLi51cGRhdGVzIH0gOiB0YXNrXG4gICAgKTtcblxuICAgIGF3YWl0IHVwZGF0ZUdvYWwodXNlcklkLCBnb2FsSWQsIHsgdGFza3M6IHVwZGF0ZWRUYXNrcyB9KTtcbn07XG5cbi8vIEFkZCBhIEdpdEh1YiBwdXNoIHRvIGEgZ29hbFxuZXhwb3J0IGNvbnN0IGFkZEdpdEh1YlB1c2hUb0dvYWwgPSBhc3luYyAodXNlcklkOiBzdHJpbmcsIGdvYWxJZDogc3RyaW5nLCBwdXNoOiBPbWl0PEdpdEh1YlB1c2gsICdpZCc+KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKCFpc0ZpcmViYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJlYmFzZSBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZ29hbCA9IGF3YWl0IGdldEdvYWxCeUlkKHVzZXJJZCwgZ29hbElkKTtcbiAgICBpZiAoIWdvYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHb2FsIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1B1c2g6IEdpdEh1YlB1c2ggPSB7XG4gICAgICAgIC4uLnB1c2gsXG4gICAgICAgIGlkOiBgcHVzaF8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsXG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZWRQdXNoZXMgPSBbLi4uZ29hbC5naXRodWJQdXNoZXMsIG5ld1B1c2hdO1xuICAgIGF3YWl0IHVwZGF0ZUdvYWwodXNlcklkLCBnb2FsSWQsIHsgZ2l0aHViUHVzaGVzOiB1cGRhdGVkUHVzaGVzIH0pO1xufTtcblxuLy8gR2V0IGdvYWxzIGJ5IHN0YXR1cyBmb3IgYSBzcGVjaWZpYyB1c2VyXG5leHBvcnQgY29uc3QgZ2V0R29hbHNCeVN0YXR1cyA9IGFzeW5jICh1c2VySWQ6IHN0cmluZywgc3RhdHVzOiAnYWxsJyB8ICdhY3RpdmUnIHwgJ2NvbXBsZXRlZCcgfCAncGF1c2VkJyk6IFByb21pc2U8R29hbFtdPiA9PiB7XG4gICAgaWYgKCFpc0ZpcmViYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGaXJlYmFzZSBub3QgYXZhaWxhYmxlLCByZXR1cm5pbmcgZW1wdHkgYXJyYXknKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIGxldCBxO1xuICAgICAgICBpZiAoc3RhdHVzID09PSAnYWxsJykge1xuICAgICAgICAgICAgcSA9IHF1ZXJ5KFxuICAgICAgICAgICAgICAgIGdldFVzZXJHb2Fsc0NvbGxlY3Rpb24odXNlcklkKSxcbiAgICAgICAgICAgICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcSA9IHF1ZXJ5KFxuICAgICAgICAgICAgICAgIGdldFVzZXJHb2Fsc0NvbGxlY3Rpb24odXNlcklkKSxcbiAgICAgICAgICAgICAgICB3aGVyZSgnc3RhdHVzJywgJz09Jywgc3RhdHVzKSxcbiAgICAgICAgICAgICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBxdWVyeVNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xuICAgICAgICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgICAgICAgIHVzZXJJZCwgLy8gQWRkIHVzZXJJZCBiYWNrIHRvIHRoZSBnb2FsIG9iamVjdFxuICAgICAgICAgICAgLi4uZG9jLmRhdGEoKSxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogZG9jLmRhdGEoKS5jcmVhdGVkQXQ/LnRvRGF0ZSgpIHx8IG5ldyBEYXRlKCksXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IGRvYy5kYXRhKCkudXBkYXRlZEF0Py50b0RhdGUoKSB8fCBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgdGFyZ2V0RGF0ZTogZG9jLmRhdGEoKS50YXJnZXREYXRlPy50b0RhdGUoKSB8fCBuZXcgRGF0ZSgpLFxuICAgICAgICB9KSkgYXMgR29hbFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZ29hbHMgYnkgc3RhdHVzOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOlsiZGIiLCJjb2xsZWN0aW9uIiwiYWRkRG9jIiwiZ2V0RG9jcyIsImdldERvYyIsInVwZGF0ZURvYyIsImRlbGV0ZURvYyIsImRvYyIsInF1ZXJ5Iiwid2hlcmUiLCJvcmRlckJ5IiwiVGltZXN0YW1wIiwic2V0RG9jIiwiaXNGaXJlYmFzZUF2YWlsYWJsZSIsInVuZGVmaW5lZCIsImdldFVzZXJHb2Fsc0NvbGxlY3Rpb24iLCJ1c2VySWQiLCJFcnJvciIsImdldFVzZXJEb2N1bWVudCIsImdldFRhc2tzQ29sbGVjdGlvbiIsImdvYWxJZCIsImNyZWF0ZUdvYWwiLCJnb2FsRGF0YSIsImdvYWxXaXRob3V0VXNlcklkIiwidXNlckRvY1JlZiIsImNyZWF0ZWRBdCIsIm5vdyIsInVwZGF0ZWRBdCIsIm1lcmdlIiwiZ29hbFdpdGhUaW1lc3RhbXBzIiwiZG9jUmVmIiwiaWQiLCJjcmVhdGVUYXNrIiwidGFza0RhdGEiLCJ0YXNrV2l0aFRpbWVzdGFtcHMiLCJnZXRHb2FsVGFza3MiLCJjb25zb2xlIiwid2FybiIsInEiLCJxdWVyeVNuYXBzaG90IiwiZG9jcyIsIm1hcCIsImRhdGEiLCJ0b0RhdGUiLCJEYXRlIiwiZXJyb3IiLCJ1cGRhdGVUYXNrIiwidGFza0lkIiwidXBkYXRlcyIsImRlbGV0ZVRhc2siLCJnZXRVc2VyR29hbHMiLCJ0YXJnZXREYXRlIiwiZ2V0R29hbEJ5SWQiLCJkb2NTbmFwIiwiZXhpc3RzIiwidXBkYXRlR29hbCIsIl8iLCJ1cGRhdGVzV2l0aG91dFVzZXJJZCIsImRlbGV0ZUdvYWwiLCJhZGRUYXNrVG9Hb2FsIiwidGFzayIsImdvYWwiLCJuZXdUYXNrIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwidXBkYXRlZFRhc2tzIiwidGFza3MiLCJ1cGRhdGVUYXNrSW5Hb2FsIiwiYWRkR2l0SHViUHVzaFRvR29hbCIsInB1c2giLCJuZXdQdXNoIiwidXBkYXRlZFB1c2hlcyIsImdpdGh1YlB1c2hlcyIsImdldEdvYWxzQnlTdGF0dXMiLCJzdGF0dXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/goals.ts\n"));

/***/ })

});